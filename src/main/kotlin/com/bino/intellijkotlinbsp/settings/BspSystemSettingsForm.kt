package com.bino.intellijkotlinbsp.settings

import com.intellij.uiDesigner.core.GridConstraints
import com.intellij.uiDesigner.core.GridLayoutManager
import com.intellij.uiDesigner.core.Spacer
import java.awt.Insets
import java.lang.reflect.Method
import java.util.*
import javax.swing.*

open class BspSystemSettingsForm {
    lateinit var content: JPanel
    lateinit var traceBspCheckbox: JCheckBox

    init {
// GUI initializer generated by IntelliJ IDEA GUI Designer
// >>> IMPORTANT!! <<<
// DO NOT EDIT OR ADD ANY CODE HERE!
        `$$$setupUI$$$`()
    }

    /**
     * Method generated by IntelliJ IDEA GUI Designer
     * >>> IMPORTANT!! <<<
     * DO NOT edit this method OR call it in your code!
     *
     * @noinspection ALL
     */
    private fun `$$$setupUI$$$`() {
        content = JPanel()
        content!!.layout = GridLayoutManager(2, 2, Insets(0, 0, 0, 0), -1, -1)
        val spacer1 = Spacer()
        content!!.add(
            spacer1,
            GridConstraints(
                1,
                0,
                1,
                1,
                GridConstraints.ANCHOR_CENTER,
                GridConstraints.FILL_VERTICAL,
                1,
                GridConstraints.SIZEPOLICY_WANT_GROW,
                null,
                null,
                null,
                0,
                false
            )
        )
        val label1 = JLabel()
        this.`$$$loadLabelText$$$`(
            label1,
            this.`$$$getMessageFromBundle$$$`("messages/ScalaBspBundle", "bsp.trace.log")
        )
        content!!.add(
            label1,
            GridConstraints(
                0,
                0,
                1,
                1,
                GridConstraints.ANCHOR_WEST,
                GridConstraints.FILL_NONE,
                GridConstraints.SIZEPOLICY_FIXED,
                GridConstraints.SIZEPOLICY_FIXED,
                null,
                null,
                null,
                0,
                false
            )
        )
        traceBspCheckbox = JCheckBox()
        this.`$$$loadButtonText$$$`(
            traceBspCheckbox!!,
            this.`$$$getMessageFromBundle$$$`("messages/ScalaBspBundle", "bcp.trace.log.enable")
        )
        content!!.add(
            traceBspCheckbox,
            GridConstraints(
                0,
                1,
                1,
                1,
                GridConstraints.ANCHOR_WEST,
                GridConstraints.FILL_NONE,
                GridConstraints.SIZEPOLICY_CAN_SHRINK or GridConstraints.SIZEPOLICY_CAN_GROW,
                GridConstraints.SIZEPOLICY_FIXED,
                null,
                null,
                null,
                0,
                false
            )
        )
    }

    private fun `$$$getMessageFromBundle$$$`(path: String, key: String): String {
        var bundle: ResourceBundle
        try {
            val thisClass: Class<*> = this.javaClass
            if (`$$$cachedGetBundleMethod$$$` == null) {
                val dynamicBundleClass = thisClass.classLoader.loadClass("com.intellij.DynamicBundle")
                `$$$cachedGetBundleMethod$$$` = dynamicBundleClass.getMethod(
                    "getBundle",
                    String::class.java,
                    Class::class.java
                )
            }
            bundle = `$$$cachedGetBundleMethod$$$`!!.invoke(null, path, thisClass) as ResourceBundle
        } catch (e: Exception) {
            bundle = ResourceBundle.getBundle(path)
        }
        return bundle.getString(key)
    }

    /**
     * @noinspection ALL
     */
    private fun `$$$loadLabelText$$$`(component: JLabel, text: String) {
        val result = StringBuffer()
        var haveMnemonic = false
        var mnemonic = '\u0000'
        var mnemonicIndex = -1
        var i = 0
        while (i < text.length) {
            if (text[i] == '&') {
                i++
                if (i == text.length) break
                if (!haveMnemonic && text[i] != '&') {
                    haveMnemonic = true
                    mnemonic = text[i]
                    mnemonicIndex = result.length
                }
            }
            result.append(text[i])
            i++
        }
        component.text = result.toString()
        if (haveMnemonic) {
            component.setDisplayedMnemonic(mnemonic)
            component.displayedMnemonicIndex = mnemonicIndex
        }
    }

    /**
     * @noinspection ALL
     */
    private fun `$$$loadButtonText$$$`(component: AbstractButton, text: String) {
        val result = StringBuffer()
        var haveMnemonic = false
        var mnemonic = '\u0000'
        var mnemonicIndex = -1
        var i = 0
        while (i < text.length) {
            if (text[i] == '&') {
                i++
                if (i == text.length) break
                if (!haveMnemonic && text[i] != '&') {
                    haveMnemonic = true
                    mnemonic = text[i]
                    mnemonicIndex = result.length
                }
            }
            result.append(text[i])
            i++
        }
        component.text = result.toString()
        if (haveMnemonic) {
            component.setMnemonic(mnemonic)
            component.displayedMnemonicIndex = mnemonicIndex
        }
    }

    /**
     * @noinspection ALL
     */
    fun `$$$getRootComponent$$$`(): JComponent? {
        return content
    }

    companion object {
        private var `$$$cachedGetBundleMethod$$$`: Method? = null
    }
}
